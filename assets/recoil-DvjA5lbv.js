import{R as q,a as Pr,j as ee,c as Or,d as xr}from"./index-dU5Uz-wX.js";import{g as Fr,S as zr,C as Wr,N as Gr,a as Kr,G as jr,b as Hr,E as qr,c as Zr,V as Yr,d as Xr,e as Jr}from"./index-BKi-f4Le.js";var Qn={};function Qr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var ea=Qr,U=ea;function ta(e){return!!e&&typeof e.then=="function"}var W=ta;function na(e,t){if(e!=null)return e;throw U(t??"Got unexpected null or undefined")}var H=na;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class wt{getValue(){throw U("BaseLoadable")}toPromise(){throw U("BaseLoadable")}valueMaybe(){throw U("BaseLoadable")}valueOrThrow(){throw U(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw U("BaseLoadable")}promiseOrThrow(){throw U(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw U("BaseLoadable")}errorOrThrow(){throw U(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw U("BaseLoadable")}}class oa extends wt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return W(n)?Ce(n):Oe(n)?n:at(n)}catch(n){return W(n)?Ce(n.next(()=>this.map(t))):Et(n)}}}class ra extends wt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class eo extends wt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ce(this.contents.then(n=>{const o=t(n);if(Oe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(W(n))return n.then(()=>this.map(t).contents);throw n}))}}function at(e){return Object.freeze(new oa(e))}function Et(e){return Object.freeze(new ra(e))}function Ce(e){return Object.freeze(new eo(e))}function to(){return Object.freeze(new eo(new Promise(()=>{})))}function aa(e){return e.every(t=>t.state==="hasValue")?at(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?Et(H(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ce(Promise.all(e.map(t=>t.contents)))}function no(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Oe(r)?r:W(r)?Ce(r):at(r)),o=aa(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Oe(e){return e instanceof wt}const sa={of:e=>W(e)?Ce(e):Oe(e)?e:at(e),error:e=>Et(e),loading:()=>to(),all:no,isLoadable:Oe};var $e={loadableWithValue:at,loadableWithError:Et,loadableWithPromise:Ce,loadableLoading:to,loadableAll:no,isLoadable:Oe,RecoilLoadable:sa},ia=$e.loadableWithValue,ca=$e.loadableWithError,la=$e.loadableWithPromise,ua=$e.loadableLoading,da=$e.loadableAll,fa=$e.isLoadable,ha=$e.RecoilLoadable,st=Object.freeze({__proto__:null,loadableWithValue:ia,loadableWithError:ca,loadableWithPromise:la,loadableLoading:ua,loadableAll:da,isLoadable:fa,RecoilLoadable:ha});const tn={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function va(e,t){var n,o;const r=(n=Qn[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw U(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function pa(e,t){var n;const o=(n=Qn[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function _a(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(va("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{tn.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),pa("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{tn.RECOIL_GKS_ENABLED.add(n)})}))}_a();var Ge=tn;function At(e){return Ge.RECOIL_GKS_ENABLED.has(e)}At.setPass=e=>{Ge.RECOIL_GKS_ENABLED.add(e)};At.setFail=e=>{Ge.RECOIL_GKS_ENABLED.delete(e)};At.clear=()=>{Ge.RECOIL_GKS_ENABLED.clear()};var z=At;function Sa(e,t,{error:n}={}){return null}var ma=Sa,dn=ma,Ht,qt,Zt;const Ra=(Ht=q.createMutableSource)!==null&&Ht!==void 0?Ht:q.unstable_createMutableSource,oo=(qt=q.useMutableSource)!==null&&qt!==void 0?qt:q.unstable_useMutableSource,ro=(Zt=q.useSyncExternalStore)!==null&&Zt!==void 0?Zt:q.unstable_useSyncExternalStore;function ya(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=q.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function ga(){return z("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:z("recoil_sync_external_store")&&ro!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:z("recoil_mutable_source")&&oo!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?z("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:z("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function ba(){return!1}var it={createMutableSource:Ra,useMutableSource:oo,useSyncExternalStore:ro,currentRendererSupportsUseSyncExternalStore:ya,reactMode:ga,isFastRefreshEnabled:ba};class fn{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class ao extends fn{}class so extends fn{}function Ta(e){return e instanceof ao||e instanceof so}var Nt={AbstractRecoilValue:fn,RecoilState:ao,RecoilValueReadOnly:so,isRecoilValue:Ta},wa=Nt.AbstractRecoilValue,Ea=Nt.RecoilState,Aa=Nt.RecoilValueReadOnly,Na=Nt.isRecoilValue,xe=Object.freeze({__proto__:null,AbstractRecoilValue:wa,RecoilState:Ea,RecoilValueReadOnly:Aa,isRecoilValue:Na});function La(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var Lt=La;class io{}const Ca=new io,Ve=new Map,hn=new Map;function Va(e){return Lt(e,t=>H(hn.get(t)))}function $a(e){if(Ve.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function Ma(e){Ge.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&$a(e.key),Ve.set(e.key,e);const t=e.set==null?new xe.RecoilValueReadOnly(e.key):new xe.RecoilState(e.key);return hn.set(e.key,t),t}class co extends Error{}function Ua(e){const t=Ve.get(e);if(t==null)throw new co(`Missing definition for RecoilValue: "${e}""`);return t}function Ia(e){return Ve.get(e)}const yt=new Map;function ka(e){var t;if(!z("recoil_memory_managament_2020"))return;const n=Ve.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ve.delete(e),(o=lo(e))===null||o===void 0||o(),yt.delete(e)}}function Da(e,t){z("recoil_memory_managament_2020")&&(t===void 0?yt.delete(e):yt.set(e,t))}function lo(e){return yt.get(e)}var ce={nodes:Ve,recoilValues:hn,registerNode:Ma,getNode:Ua,getNodeMaybe:Ia,deleteNodeConfigIfPossible:ka,setConfigDeletionHandler:Da,getConfigDeletionHandler:lo,recoilValuesForKeys:Va,NodeMissingError:co,DefaultValue:io,DEFAULT_VALUE:Ca};function Ba(e,t){t()}var Pa={enqueueExecution:Ba};function Oa(e,t){return t={exports:{}},e(t,t.exports),t.exports}var xa=Oa(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},v=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,m=0,R=c.length;m<R;++m){var g=c.charCodeAt(m);h=(h<<5)-h+g|0}return h},_=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},V=function(i,h){return h>>>i&a},C=function(i){return 1<<i},y=function(i,h){return _(i&h-1)},E=function(i,h,m,R){var g=R;if(!i){var L=R.length;g=new Array(L);for(var A=0;A<L;++A)g[A]=R[A]}return g[h]=m,g},Z=function(i,h,m){var R=m.length-1,g=0,L=0,A=m;if(i)g=L=h;else for(A=new Array(R);g<h;)A[L++]=m[g++];for(++g;g<=R;)A[L++]=m[g++];return i&&(A.length=R),A},oe=function(i,h,m,R){var g=R.length;if(i){for(var L=g;L>=h;)R[L--]=R[L];return R[h]=m,R}for(var A=0,N=0,I=new Array(g+1);A<h;)I[N++]=R[A++];for(I[h]=m;A<g;)I[++N]=R[A++];return I},w=1,B=2,J=3,F=4,G={__hamt_isEmpty:!0},Y=function(i){return i===G||i&&i.__hamt_isEmpty},ae=function(i,h,m,R){return{type:w,edit:i,hash:h,key:m,value:R,_modify:Ie}},ye=function(i,h,m){return{type:B,edit:i,hash:h,children:m,_modify:ke}},te=function(i,h,m){return{type:J,edit:i,mask:h,children:m,_modify:P}},de=function(i,h,m){return{type:F,edit:i,size:h,children:m,_modify:O}},Ue=function(i){return i===G||i.type===w||i.type===B},Q=function(i,h,m,R,g){for(var L=[],A=R,N=0,I=0;A;++I)A&1&&(L[I]=g[N++]),A>>>=1;return L[h]=m,de(i,N+1,L)},le=function(i,h,m,R){for(var g=new Array(h-1),L=0,A=0,N=0,I=R.length;N<I;++N)if(N!==m){var j=R[N];j&&!Y(j)&&(g[L++]=j,A|=1<<N)}return te(i,A,g)},Ae=function c(i,h,m,R,g,L){if(m===g)return ye(i,m,[L,R]);var A=V(h,m),N=V(h,g);return te(i,C(A)|C(N),A===N?[c(i,h+o,m,R,g,L)]:A<N?[R,L]:[L,R])},fe=function(i,h,m,R,g,L,A,N){for(var I=g.length,j=0;j<I;++j){var se=g[j];if(m(A,se.key)){var re=se.value,ve=L(re);return ve===re?g:ve===u?(--N.value,Z(i,j,g)):E(i,j,ae(h,R,A,ve),g)}}var _e=L();return _e===u?g:(++N.value,E(i,I,ae(h,R,A,_e),g))},ge=function(i,h){return i===h.edit},Ie=function(i,h,m,R,g,L,A){if(h(L,this.key)){var N=R(this.value);return N===this.value?this:N===u?(--A.value,G):ge(i,this)?(this.value=N,this):ae(i,g,L,N)}var I=R();return I===u?this:(++A.value,Ae(i,m,this.hash,this,g,ae(i,g,L,I)))},ke=function(i,h,m,R,g,L,A){if(g===this.hash){var N=ge(i,this),I=fe(N,i,h,this.hash,this.children,R,L,A);return I===this.children?this:I.length>1?ye(i,this.hash,I):I[0]}var j=R();return j===u?this:(++A.value,Ae(i,m,this.hash,this,g,ae(i,g,L,j)))},P=function(i,h,m,R,g,L,A){var N=this.mask,I=this.children,j=V(m,g),se=C(j),re=y(N,se),ve=N&se,_e=ve?I[re]:G,De=_e._modify(i,h,m+o,R,g,L,A);if(_e===De)return this;var ht=ge(i,this),qe=N,Ze=void 0;if(ve&&Y(De)){if(qe&=~se,!qe)return G;if(I.length<=2&&Ue(I[re^1]))return I[re^1];Ze=Z(ht,re,I)}else if(!ve&&!Y(De)){if(I.length>=s)return Q(i,j,De,N,I);qe|=se,Ze=oe(ht,re,De,I)}else Ze=E(ht,re,De,I);return ht?(this.mask=qe,this.children=Ze,this):te(i,qe,Ze)},O=function(i,h,m,R,g,L,A){var N=this.size,I=this.children,j=V(m,g),se=I[j],re=(se||G)._modify(i,h,m+o,R,g,L,A);if(se===re)return this;var ve=ge(i,this),_e=void 0;if(Y(se)&&!Y(re))++N,_e=E(ve,j,re,I);else if(!Y(se)&&Y(re)){if(--N,N<=l)return le(i,N,j,I);_e=E(ve,j,G,I)}else _e=E(ve,j,re,I);return ve?(this.size=N,this.children=_e,this):de(i,N,_e)};G._modify=function(c,i,h,m,R,g,L){var A=m();return A===u?G:(++L.value,ae(c,R,g,A))};function d(c,i,h,m,R){this._editable=c,this._edit=i,this._config=h,this._root=m,this._size=R}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var p=n.tryGetHash=function(c,i,h,m){for(var R=m._root,g=0,L=m._config.keyEq;;)switch(R.type){case w:return L(h,R.key)?R.value:c;case B:{if(i===R.hash)for(var A=R.children,N=0,I=A.length;N<I;++N){var j=A[N];if(L(h,j.key))return j.value}return c}case J:{var se=V(g,i),re=C(se);if(R.mask&re){R=R.children[y(R.mask,re)],g+=o;break}return c}case F:{if(R=R.children[V(g,i)],R){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return p(c,i,h,this)};var S=n.tryGet=function(c,i,h){return p(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return p(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return p(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return p(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var D=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return D(c,this)};var k=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||k,hash:c&&c.hash||v},G,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!Y(c._root)};d.prototype.isEmpty=function(){return T(this)};var K=n.modifyHash=function(c,i,h,m){var R={value:m._size},g=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,c,i,h,R);return m.setTree(g,R.value)};d.prototype.modifyHash=function(c,i,h){return K(h,c,i,this)};var ne=n.modify=function(c,i,h){return K(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return ne(i,c,this)};var x=n.setHash=function(c,i,h,m){return K(f(h),c,i,m)};d.prototype.setHash=function(c,i,h){return x(c,i,h,this)};var X=n.set=function(c,i,h){return x(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return X(c,i,this)};var pe=f(u),Ne=n.removeHash=function(c,i,h){return K(pe,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ne(c,i,this)};var he=n.remove=function(c,i){return Ne(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return he(c,this)};var ue=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return ue(this)};var Nn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return Nn(this)};var Lr=n.mutate=function(c,i){var h=ue(i);return c(h),Nn(h)};d.prototype.mutate=function(c){return Lr(c,this)};var Gt=function(i){return i&&Ln(i[0],i[1],i[2],i[3],i[4])},Ln=function(i,h,m,R,g){for(;m<i;){var L=h[m++];if(L&&!Y(L))return Cn(L,R,[i,h,m,R,g])}return Gt(g)},Cn=function(i,h,m){switch(i.type){case w:return{value:h(i),rest:m};case B:case F:case J:var R=i.children;return Ln(R.length,R,0,h,m);default:return Gt(m)}},Cr={done:!0};function Kt(c){this.v=c}Kt.prototype.next=function(){if(!this.v)return Cr;var c=this.v;return this.v=Gt(c.rest),c},Kt.prototype[Symbol.iterator]=function(){return this};var jt=function(i,h){return new Kt(Cn(i._root,h))},Vr=function(i){return[i.key,i.value]},$r=n.entries=function(c){return jt(c,Vr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return $r(this)};var Mr=function(i){return i.key},Ur=n.keys=function(c){return jt(c,Mr)};d.prototype.keys=function(){return Ur(this)};var Ir=function(i){return i.value},kr=n.values=d.prototype.values=function(c){return jt(c,Ir)};d.prototype.values=function(){return kr(this)};var Vn=n.fold=function(c,i,h){var m=h._root;if(m.type===w)return c(i,m.value,m.key);for(var R=[m.children],g=void 0;g=R.pop();)for(var L=0,A=g.length;L<A;){var N=g[L++];N&&N.type&&(N.type===w?i=c(i,N.value,N.key):R.push(N.children))}return i};d.prototype.fold=function(c,i){return Vn(c,i,this)};var Dr=n.forEach=function(c,i){return Vn(function(h,m,R){return c(m,R,i)},null,i)};d.prototype.forEach=function(c){return Dr(c,this)};var Br=n.count=function(c){return c._size};d.prototype.count=function(){return Br(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class Fa{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return pn(this)}toMap(){return new Map(this._map)}}class vn{constructor(t){if(M(this,"_hamt",xa.empty.beginMutation()),t instanceof vn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return pn(this)}toMap(){return new Map(this._hamt)}}function pn(e){return z("recoil_hamt_2020")?new vn(e):new Fa(e)}var za={persistentMap:pn},Wa=za.persistentMap,Ga=Object.freeze({__proto__:null,persistentMap:Wa});function Ka(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var nt=Ka;function ja(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var gt=ja;function Ha(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function qa(e){return{nodeDeps:gt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:gt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Yt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:nt(t,s);for(const u of l)a.has(u)||a.set(u,new Set),H(a.get(u)).add(e);if(s){const u=nt(s,t);for(const f of u){if(!a.has(f))return;const v=H(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function Za(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(Yt(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const _=n.getGraph(u.currentTree.version);Yt(e,t,_,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var v;const _=(v=u.nextTree)===null||v===void 0?void 0:v.version;if(_!==void 0){const V=n.getGraph(_);Yt(e,t,V,f)}}}var ct={cloneGraph:qa,graph:Ha,saveDepsToStore:Za};let Ya=0;const Xa=()=>Ya++;let Ja=0;const Qa=()=>Ja++;let es=0;const ts=()=>es++;var Ct={getNextTreeStateVersion:Xa,getNextStoreID:Qa,getNextComponentID:ts};const{persistentMap:$n}=Ga,{graph:ns}=ct,{getNextTreeStateVersion:uo}=Ct;function fo(){const e=uo();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:$n(),nonvalidatedAtoms:$n()}}function os(){const e=fo();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ns()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var ho={makeEmptyTreeState:fo,makeEmptyStoreState:os,getNextTreeStateVersion:uo};class vo{}function rs(){return new vo}var Vt={RetentionZone:vo,retentionZone:rs};function as(e,t){const n=new Set(e);return n.add(t),n}function ss(e,t){const n=new Set(e);return n.delete(t),n}function is(e,t,n){const o=new Map(e);return o.set(t,n),o}function cs(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function ls(e,t){const n=new Map(e);return n.delete(t),n}function us(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var po={setByAddingToSet:as,setByDeletingFromSet:ss,mapBySettingInMap:is,mapByUpdatingInMap:cs,mapByDeletingFromMap:ls,mapByDeletingMultipleFromMap:us};function*ds(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var _n=ds;function fs(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var _o=fs;const{getNode:lt,getNodeMaybe:hs,recoilValuesForKeys:Mn}=ce,{RetentionZone:Un}=Vt,{setByAddingToSet:vs}=po,ps=Object.freeze(new Set);class _s extends Error{}function Ss(e,t,n){if(!z("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Un)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!z("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Un)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function Sn(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=lt(n),s=Ss(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function ms(e,t,n){Sn(e,e.getState().currentTree,t,n)}function Rs(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ys(e,t,n){return Sn(e,t,n,"get"),lt(n).get(e,t)}function So(e,t,n){return lt(n).peek(e,t)}function gs(e,t,n){var o;const r=hs(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:vs(e.dirtyAtoms,t)}}function bs(e,t,n,o){const r=lt(n);if(r.set==null)throw new _s(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Sn(e,t,n,"set"),a(e,t,o)}function Ts(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=lt(n).nodeType;return _o({type:a},{loadable:()=>So(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return Mn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:Mn(_n(mo(e,t,new Set([n])),u=>u!==n)),components:Lt((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function mo(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:ps;for(const f of u)o.has(f)||r.push(f)}return o}var we={getNodeLoadable:ys,peekNodeLoadable:So,setNodeValue:bs,initializeNode:ms,cleanUpNode:Rs,setUnvalidatedAtomValue_DEPRECATED:gs,peekNodeInfo:Ts,getDownstreamNodes:mo};let Ro=null;function ws(e){Ro=e}function Es(){var e;(e=Ro)===null||e===void 0||e()}var yo={setInvalidateMemoizedSnapshot:ws,invalidateMemoizedSnapshot:Es};const{getDownstreamNodes:As,getNodeLoadable:go,setNodeValue:Ns}=we,{getNextComponentID:Ls}=Ct,{getNode:Cs,getNodeMaybe:bo}=ce,{DefaultValue:mn}=ce,{reactMode:Vs}=it,{AbstractRecoilValue:$s,RecoilState:Ms,RecoilValueReadOnly:Us,isRecoilValue:Is}=xe,{invalidateMemoizedSnapshot:ks}=yo;function Ds(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=go(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function Bs(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof mn?n.delete(r):n.set(r,o)}),n}function Ps(e,t,{key:n},o){if(typeof o=="function"){const r=go(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw U(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Os(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=Ps(e,t,r,a),l=Ns(e,t,r.key,s);for(const[u,f]of l.entries())nn(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;nn(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=bo(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else dn(`Unknown action ${n.type}`)}function nn(e,t,n){n.state==="hasValue"&&n.contents instanceof mn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function To(e,t){e.replaceState(n=>{const o=wo(n);for(const r of t)Os(e,o,r);return Eo(e,o),ks(),o})}function $t(e,t){if(ot.length){const n=ot[ot.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else To(e,[t])}const ot=[];function xs(){const e=new Map;return ot.push(e),()=>{for(const[t,n]of e)To(t,n);ot.pop()}}function wo(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Eo(e,t){const n=As(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=bo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function Ao(e,t,n){$t(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Fs(e,t,n){if(n instanceof mn)return Ao(e,t,n);$t(e,{type:"setLoadable",recoilValue:t,loadable:n})}function zs(e,t){$t(e,{type:"markModified",recoilValue:t})}function Ws(e,t,n){$t(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Gs(e,{key:t},n,o=null){const r=Ls(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),H(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=Vs();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function Ks(e,t){var n;const{currentTree:o}=e.getState(),r=Cs(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var me={RecoilValueReadOnly:Us,AbstractRecoilValue:$s,RecoilState:Ms,getRecoilValueAsLoadable:Ds,setRecoilValue:Ao,setRecoilValueLoadable:Fs,markRecoilValueModified:zs,setUnvalidatedRecoilValue:Ws,subscribeToRecoilValue:Gs,isRecoilValue:Is,applyAtomValueWrites:Bs,batchStart:xs,writeLoadableToTreeState:nn,invalidateDownstreams:Eo,copyTreeState:wo,refreshRecoilValue:Ks};function js(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Hs=js;const{cleanUpNode:qs}=we,{deleteNodeConfigIfPossible:Zs,getNode:No}=ce,{RetentionZone:Lo}=Vt,Ys=12e4,Co=new Set;function Vo(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof Lo)for(const l of ei(n,s))r.add(l);else r.add(s);const a=Xs(e,r);for(const s of a)Qs(e,o,s)}function Xs(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,v=Js(e,o,u,a,s);for(const y of v){var _;if(No(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((_=n.retention.referenceCounts.get(y))!==null&&_!==void 0?_:0)>0){s.add(y);continue}if($o(y).some(Z=>n.retention.referenceCounts.get(Z))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&Hs(E,Z=>s.has(Z))){s.add(y);continue}a.add(y),f.add(y)}const V=new Set;for(const y of f)for(const E of(C=r.nodeDeps.get(y))!==null&&C!==void 0?C:Co){var C;a.has(E)||V.add(E)}V.size&&l(V)}}function Js(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(H(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const _ of v)u(_);l.add(f),n.delete(f),s.push(f)}}function Qs(e,t,n){if(!z("recoil_memory_managament_2020"))return;qs(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=$o(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Zs(n)}function ei(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Co}function $o(e){const t=No(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Lo?[t]:t}function ti(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Vo(e,new Set([t]))}function ni(e,t,n){var o;if(!z("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Mo(e,t):r.set(t,a)}function Mo(e,t){if(!z("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),ti(e,t)}function oi(e){if(!z("recoil_memory_managament_2020"))return;const t=e.getState();Vo(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function ri(e){return e===void 0?"recoilRoot":e}var Me={SUSPENSE_TIMEOUT_MS:Ys,updateRetainCount:ni,updateRetainCountToZero:Mo,releaseScheduledRetainablesNow:oi,retainedByOptionWithDefault:ri};const{unstable_batchedUpdates:ai}=Pr;var si={unstable_batchedUpdates:ai};const{unstable_batchedUpdates:ii}=si;var ci={unstable_batchedUpdates:ii};const{batchStart:li}=me,{unstable_batchedUpdates:ui}=ci;let Rn=ui||(e=>e());const di=e=>{Rn=e},fi=()=>Rn,hi=e=>{Rn(()=>{let t=()=>{};try{t=li(),e()}finally{t()}})};var Mt={getBatcher:fi,setBatcher:di,batchUpdates:hi};function*vi(e){for(const t of e)for(const n of t)yield n}var Uo=vi;const Io=typeof Window>"u"||typeof window>"u",pi=e=>!Io&&(e===window||e instanceof Window),_i=typeof navigator<"u"&&navigator.product==="ReactNative";var Ut={isSSR:Io,isReactNative:_i,isWindow:pi};function Si(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function mi(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function Ri(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var yi={memoizeWithArgsHash:Si,memoizeOneWithArgsHash:mi,memoizeOneWithArgsHashAndInvalidation:Ri};const{batchUpdates:on}=Mt,{initializeNode:gi,peekNodeInfo:bi}=we,{graph:Ti}=ct,{getNextStoreID:wi}=Ct,{DEFAULT_VALUE:Ei,recoilValues:In,recoilValuesForKeys:kn}=ce,{AbstractRecoilValue:Ai,getRecoilValueAsLoadable:Ni,setRecoilValue:Dn,setUnvalidatedRecoilValue:Li}=me,{updateRetainCount:Rt}=Me,{setInvalidateMemoizedSnapshot:Ci}=yo,{getNextTreeStateVersion:Vi,makeEmptyStoreState:$i}=ho,{isSSR:Mi}=Ut,{memoizeOneWithArgsHashAndInvalidation:Ui}=yi;class It{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),Ni(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return kn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?In.values():o.isInitialized===!0?kn(Uo([r,a])):_n(In.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),bi(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new rn(this,on);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new rn(this,on);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:wi(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return H(r.get(o));const a=Ti();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw U("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)gi(this._store,o,"get"),Rt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){Mi||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!z("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){z("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function ko(e,t,n=!1){const o=e.getState(),r=n?Vi():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Lt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function Ii(e){const t=new It($i());return e!=null?t.map(e):t}const[Bn,Do]=Ui((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:H(o.previousTree);return new It(ko(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});Ci(Do);function ki(e,t="latest"){const n=Bn(e,t);return n.isRetained()?n:(Do(),Bn(e,t))}class rn extends It{constructor(t,n){super(ko(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{Rt(a,o.key,1),Dn(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{Rt(r,o.key,1),Dn(this.getStore_INTERNAL(),o,Ei)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();on(()=>{for(const[a,s]of o.entries())Rt(r,a,1),Li(r,new Ai(a),s)})}),this._batch=n}}var kt={Snapshot:It,MutableSnapshot:rn,freshSnapshot:Ii,cloneSnapshot:ki},Di=kt.Snapshot,Bi=kt.MutableSnapshot,Pi=kt.freshSnapshot,Oi=kt.cloneSnapshot,Dt=Object.freeze({__proto__:null,Snapshot:Di,MutableSnapshot:Bi,freshSnapshot:Pi,cloneSnapshot:Oi});function xi(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var Fi=xi;const{useRef:zi}=q;function Wi(e){const t=zi(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var Pn=Wi;const{getNextTreeStateVersion:Gi,makeEmptyStoreState:Bo}=ho,{cleanUpNode:Ki,getDownstreamNodes:ji,initializeNode:Hi,setNodeValue:qi,setUnvalidatedAtomValue_DEPRECATED:Zi}=we,{graph:Yi}=ct,{cloneGraph:Xi}=ct,{getNextStoreID:Po}=Ct,{createMutableSource:Xt,reactMode:Oo}=it,{applyAtomValueWrites:Ji}=me,{releaseScheduledRetainablesNow:xo}=Me,{freshSnapshot:Qi}=Dt,{useCallback:ec,useContext:Fo,useEffect:an,useMemo:tc,useRef:nc,useState:oc}=q;function Ye(){throw U("This component must be used inside a <RecoilRoot> component.")}const zo=Object.freeze({storeID:Po(),getState:Ye,replaceState:Ye,getGraph:Ye,subscribeToTransactions:Ye,addTransactionMetadata:Ye});let sn=!1;function On(e){if(sn)throw U("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){z("recoil_memory_managament_2020")&&z("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&xo(e);const n=t.currentTree.version,o=Gi();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Xi(H(t.graphsByVersion.get(n))))}}const Wo=q.createContext({current:zo}),Bt=()=>Fo(Wo),Go=q.createContext(null);function rc(){return Fo(Go)}function yn(e,t,n){const o=ji(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function Ko(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!Oo().early||t.suspendedComponentResolvers.size>0)&&(yn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function ac(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Ko(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):dn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,z("recoil_memory_managament_2020")&&n==null&&xo(e)}finally{t.commitDepth--}}function sc({setNotifyBatcherOfChange:e}){const t=Bt(),[,n]=oc([]);return e(()=>n({})),an(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),an(()=>{Pa.enqueueExecution("Batcher",()=>{ac(t.current)})}),null}function ic(e,t){const n=Bo();return t({set:(o,r)=>{const a=n.currentTree,s=qi(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:Fi(a.dirtyAtoms,l),atomValues:Ji(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Zi(n.currentTree,a,r)})}}),n}function cc(e){const t=Qi(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let xn=0;function lc({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=C=>{const y=r.current.graphsByVersion;if(y.has(C))return H(y.get(C));const E=Yi();return y.set(C,E),E},s=(C,y)=>{if(y==null){const{transactionSubscriptions:E}=_.current.getState(),Z=xn++;return E.set(Z,C),{release:()=>{E.delete(Z)}}}else{const{nodeTransactionSubscriptions:E}=_.current.getState();E.has(y)||E.set(y,new Map);const Z=xn++;return H(E.get(y)).set(Z,C),{release:()=>{const oe=E.get(y);oe&&(oe.delete(Z),oe.size===0&&E.delete(y))}}}},l=C=>{On(_.current);for(const y of Object.keys(C))H(_.current.getState().nextTree).transactionMetadata[y]=C[y]},u=C=>{On(_.current);const y=H(r.current.nextTree);let E;try{sn=!0,E=C(y)}finally{sn=!1}E!==y&&(r.current.nextTree=E,Oo().early&&yn(_.current,r.current,E),H(f.current)())},f=nc(null),v=ec(C=>{f.current=C},[f]),_=Pn(()=>n??{storeID:Po(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(_.current=n),r=Pn(()=>e!=null?ic(_.current,e):t!=null?cc(t):Bo());const V=tc(()=>Xt==null?void 0:Xt(r,()=>r.current.currentTree.version),[r]);return an(()=>{const C=_.current;for(const y of new Set(C.getState().knownAtoms))Hi(C,y,"get");return()=>{for(const y of C.getState().knownAtoms)Ki(C,y)}},[_]),q.createElement(Wo.Provider,{value:_},q.createElement(Go.Provider,{value:V},q.createElement(sc,{setNotifyBatcherOfChange:v}),o))}function uc(e){const{override:t,...n}=e,o=Bt();return t===!1&&o.current!==zo?e.children:q.createElement(lc,n)}function dc(){return Bt().current.storeID}var be={RecoilRoot:uc,useStoreRef:Bt,useRecoilMutableSource:rc,useRecoilStoreID:dc,notifyComponents_FOR_TESTING:yn,sendEndOfBatchNotifications_FOR_TESTING:Ko};function fc(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var hc=fc;const{useEffect:vc,useRef:pc}=q;function _c(e){const t=pc();return vc(()=>{t.current=e}),t.current}var jo=_c;const{useStoreRef:Sc}=be,{SUSPENSE_TIMEOUT_MS:mc}=Me,{updateRetainCount:Xe}=Me,{RetentionZone:Rc}=Vt,{useEffect:yc,useRef:gc}=q,{isSSR:Fn}=Ut;function bc(e){if(z("recoil_memory_managament_2020"))return Tc(e)}function Tc(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof Rc?s:s.key),o=Sc();yc(()=>{if(!z("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Fn)window.clearTimeout(r.current),r.current=null;else for(const l of n)Xe(s,l,1);return()=>{for(const l of n)Xe(s,l,-1)}},[o,...n]);const r=gc(),a=jo(n);if(!Fn&&(a===void 0||!hc(a,n))){const s=o.current;for(const l of n)Xe(s,l,1);if(a)for(const l of a)Xe(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Xe(s,l,-1)},mc)}}var gn=bc;function wc(){return"<component name not available>"}var ut=wc;const{batchUpdates:Ec}=Mt,{DEFAULT_VALUE:Ho}=ce,{currentRendererSupportsUseSyncExternalStore:Ac,reactMode:Ke,useMutableSource:Nc,useSyncExternalStore:Lc}=it,{useRecoilMutableSource:Cc,useStoreRef:Re}=be,{AbstractRecoilValue:cn,getRecoilValueAsLoadable:dt,setRecoilValue:bt,setUnvalidatedRecoilValue:Vc,subscribeToRecoilValue:Fe}=me,{useCallback:ie,useEffect:ze,useMemo:qo,useRef:rt,useState:bn}=q,{setByAddingToSet:$c}=po,{isSSR:Mc}=Ut;function Tn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),Mc&&W(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:U(`Invalid value of loadable atom "${t.key}"`)}function Uc(){const e=ut(),t=Re(),[,n]=bn([]),o=rt(new Set);o.current=new Set;const r=rt(new Set),a=rt(new Map),s=ie(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ie((u,f)=>{a.current.has(f)&&n([])},[]);return ze(()=>{const u=t.current;nt(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const v=Fe(u,new cn(f),V=>l(V,f),e);a.current.set(f,v),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),nt(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),ze(()=>{const u=a.current;return nt(o.current,new Set(u.keys())).forEach(f=>{const v=Fe(t.current,new cn(f),_=>l(_,f),e);u.set(f,v)}),()=>u.forEach((f,v)=>s(v))},[e,t,s,l]),qo(()=>{function u(y){return E=>{bt(t.current,y,E)}}function f(y){return()=>bt(t.current,y,Ho)}function v(y){var E;o.current.has(y.key)||(o.current=$c(o.current,y.key));const Z=t.current.getState();return dt(t.current,y,Ke().early&&(E=Z.nextTree)!==null&&E!==void 0?E:Z.currentTree)}function _(y){const E=v(y);return Tn(E,y,t)}function V(y){return[_(y),u(y)]}function C(y){return[v(y),u(y)]}return{getRecoilValue:_,getRecoilValueLoadable:v,getRecoilState:V,getRecoilStateLoadable:C,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const Ic={current:0};function kc(e){const t=Re(),n=ut(),o=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:dt(u,e,v),key:e.key}},[t,e]),r=ie(l=>{let u;return()=>{var f,v;const _=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(_.loadable)&&((v=u)===null||v===void 0?void 0:v.key)===_.key?u:(u=_,_)}},[]),a=qo(()=>r(o),[o,r]),s=ie(l=>{const u=t.current;return Fe(u,e,l,n).release},[t,e,n]);return Lc(s,a,a).loadable}function Dc(e){const t=Re(),n=ie(()=>{var f;const v=t.current,_=v.getState(),V=Ke().early&&(f=_.nextTree)!==null&&f!==void 0?f:_.currentTree;return dt(v,e,V)},[t,e]),o=ie(()=>n(),[n]),r=ut(),a=ie((f,v)=>{const _=t.current;return Fe(_,e,()=>{if(!z("recoil_suppress_rerender_in_callback"))return v();const C=n();u.current.is(C)||v(),u.current=C},r).release},[t,e,r,n]),s=Cc();if(s==null)throw U("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=Nc(s,o,a),u=rt(l);return ze(()=>{u.current=l}),l}function ln(e){const t=Re(),n=ut(),o=ie(()=>{var u;const f=t.current,v=f.getState(),_=Ke().early&&(u=v.nextTree)!==null&&u!==void 0?u:v.currentTree;return dt(f,e,_)},[t,e]),r=ie(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ie(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);ze(()=>{const u=Fe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=bn(r);return s.key!==e.key?r().loadable:s.loadable}function Bc(e){const t=Re(),[,n]=bn([]),o=ut(),r=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return dt(u,e,v)},[t,e]),a=r(),s=rt(a);return ze(()=>{s.current=a}),ze(()=>{const l=t.current,u=l.getState(),f=Fe(l,e,_=>{var V;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const C=r();(V=s.current)!==null&&V!==void 0&&V.is(C)||n(C),s.current=C},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const _=r();(v=s.current)!==null&&v!==void 0&&v.is(_)||n(_),s.current=_}return f.release},[o,r,e,t]),a}function wn(e){return z("recoil_memory_managament_2020")&&gn(e),{TRANSITION_SUPPORT:ln,SYNC_EXTERNAL_STORE:Ac()?kc:ln,MUTABLE_SOURCE:Dc,LEGACY:Bc}[Ke().mode](e)}function Zo(e){const t=Re(),n=wn(e);return Tn(n,e,t)}function Pt(e){const t=Re();return ie(n=>{bt(t.current,e,n)},[t,e])}function Pc(e){const t=Re();return ie(()=>{bt(t.current,e,Ho)},[t,e])}function Oc(e){return[Zo(e),Pt(e)]}function xc(e){return[wn(e),Pt(e)]}function Fc(){const e=Re();return(t,n={})=>{Ec(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>Vc(e.current,new cn(r),o))})}}function Yo(e){return z("recoil_memory_managament_2020")&&gn(e),ln(e)}function Xo(e){const t=Re(),n=Yo(e);return Tn(n,e,t)}function zc(e){return[Xo(e),Pt(e)]}var Wc={recoilComponentGetRecoilValueCount_FOR_TESTING:Ic,useRecoilInterface:Uc,useRecoilState:Oc,useRecoilStateLoadable:xc,useRecoilValue:Zo,useRecoilValueLoadable:wn,useResetRecoilState:Pc,useSetRecoilState:Pt,useSetUnvalidatedAtomValues:Fc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Yo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Xo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:zc};function Gc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var Kc=Gc;function jc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var Hc=jc;function qc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Zc=qc;const{batchUpdates:Yc}=Mt,{DEFAULT_VALUE:Xc,getNode:Jo,nodes:Jc}=ce,{useStoreRef:En}=be,{AbstractRecoilValue:Qc,setRecoilValueLoadable:el}=me,{SUSPENSE_TIMEOUT_MS:tl}=Me,{cloneSnapshot:Tt}=Dt,{useCallback:Ot,useEffect:Qo,useRef:zn,useState:nl}=q,{isSSR:Wn}=Ut;function xt(e){const t=En();Qo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Gn(e){const t=e.atomValues.toMap(),n=gt(Kc(t,(o,r)=>{const s=Jo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Zc(e.nonvalidatedAtoms.toMap(),n)}function ol(e){xt(Ot(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Gn(o),a=Gn(n),s=gt(Jc,u=>{var f,v,_,V;return{persistence_UNSTABLE:{type:(f=(v=u.persistence_UNSTABLE)===null||v===void 0?void 0:v.type)!==null&&f!==void 0?f:"none",backButton:(_=(V=u.persistence_UNSTABLE)===null||V===void 0?void 0:V.backButton)!==null&&_!==void 0?_:!1}}}),l=Hc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function rl(e){xt(Ot(t=>{const n=Tt(t,"latest"),o=Tt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function al(){const e=En(),[t,n]=nl(()=>Tt(e.current)),o=jo(t),r=zn(),a=zn();if(xt(Ot(l=>n(Tt(l)),[])),Qo(()=>{const l=t.retain();if(r.current&&!Wn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!Wn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},tl)}return t}function er(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Yc(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var l,u;((l=r.atomValues.get(v))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(v))===null||u===void 0?void 0:u.contents)&&Jo(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{el(e,new Qc(f),a.atomValues.has(f)?H(a.atomValues.get(f)):Xc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function sl(){const e=En();return Ot(t=>er(e.current,t),[e])}var tr={useRecoilSnapshot:al,gotoSnapshot:er,useGotoRecoilSnapshot:sl,useRecoilTransactionObserver:rl,useTransactionObservation_DEPRECATED:ol,useTransactionSubscription_DEPRECATED:xt};const{peekNodeInfo:il}=we,{useStoreRef:cl}=be;function ll(){const e=cl();return({key:t})=>il(e.current,e.current.getState().currentTree,t)}var ul=ll;const{reactMode:dl}=it,{RecoilRoot:fl,useStoreRef:hl}=be,{useMemo:vl}=q;function pl(){dl().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=hl().current;return vl(()=>{function t({children:n}){return q.createElement(fl,{store_INTERNAL:e},n)}return t},[e])}var _l=pl;const{loadableWithValue:Sl}=st,{initializeNode:ml}=we,{DEFAULT_VALUE:Rl,getNode:yl}=ce,{copyTreeState:gl,getRecoilValueAsLoadable:bl,invalidateDownstreams:Tl,writeLoadableToTreeState:wl}=me;function Kn(e){return yl(e.key).nodeType==="atom"}class El{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Kn(o))throw U("Reading selectors within atomicUpdate is not supported");const r=bl(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:U(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!Kn(o))throw U("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else ml(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,Rl)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=gl(this._treeState);for(const[n,o]of this._changes)wl(t,n,Sl(o));return Tl(this._store,t),t}}function Al(e){return t=>{e.replaceState(n=>{const o=new El(e,n);return t(o),o.newTreeState_INTERNAL()})}}var Nl={atomicUpdater:Al},Ll=Nl.atomicUpdater,nr=Object.freeze({__proto__:null,atomicUpdater:Ll});function Cl(e,t){if(!e)throw new Error(t)}var Vl=Cl,tt=Vl;const{atomicUpdater:$l}=nr,{batchUpdates:Ml}=Mt,{DEFAULT_VALUE:Ul}=ce,{useStoreRef:Il}=be,{refreshRecoilValue:kl,setRecoilValue:jn}=me,{cloneSnapshot:Dl}=Dt,{gotoSnapshot:Bl}=tr,{useCallback:Pl}=q;class or{}const Ol=new or;function rr(e,t,n,o){let r=Ol,a;if(Ml(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw U(l);const u=_o({...o??{},set:(v,_)=>jn(e,v,_),reset:v=>jn(e,v,Ul),refresh:v=>kl(e,v),gotoSnapshot:v=>Bl(e,v),transact_UNSTABLE:v=>$l(e)(v)},{snapshot:()=>{const v=Dl(e);return a=v.retain(),v}}),f=t(u);if(typeof f!="function")throw U(l);r=f(...n)}),r instanceof or&&tt(!1),W(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function xl(e,t){const n=Il();return Pl((...o)=>rr(n.current,e,o),t!=null?[...t,n]:void 0)}var ar={recoilCallback:rr,useRecoilCallback:xl};const{useStoreRef:Fl}=be,{refreshRecoilValue:zl}=me,{useCallback:Wl}=q;function Gl(e){const t=Fl();return Wl(()=>{const n=t.current;zl(n,e)},[e,t])}var Kl=Gl;const{atomicUpdater:jl}=nr,{useStoreRef:Hl}=be,{useMemo:ql}=q;function Zl(e,t){const n=Hl();return ql(()=>(...o)=>{jl(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Yl=Zl;class Xl{constructor(t){M(this,"value",void 0),this.value=t}}var Jl={WrappedValue:Xl},Ql=Jl.WrappedValue,sr=Object.freeze({__proto__:null,WrappedValue:Ql});const{isFastRefreshEnabled:eu}=it;class Hn extends Error{}class tu{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,v;for(const[Z,oe]of t){var _,V,C;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const B=f;if(f=B?B.branches.get(v):w,f=(_=f)!==null&&_!==void 0?_:{type:"branch",nodeKey:Z,parent:B,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Z)throw this.invalidCacheError();B==null||B.branches.set(v,f),o==null||(V=o.onNodeVisit)===null||V===void 0||V.call(o,f),v=this._mapNodeValue(oe),this._root=(C=this._root)!==null&&C!==void 0?C:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==v))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Hn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=eu()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw dn(t+(this._name!=null?` - ${this._name}`:"")),new Hn}}var nu={TreeCache:tu},ou=nu.TreeCache,ir=Object.freeze({__proto__:null,TreeCache:ou});class ru{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=H(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var au={LRUCache:ru},su=au.LRUCache,cr=Object.freeze({__proto__:null,LRUCache:su});const{LRUCache:iu}=cr,{TreeCache:cu}=ir;function lu({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new iu({maxSize:t}),r=new cu({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var qn=lu;function Se(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw U("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(W(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>Se(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return Se(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:Se(a,t)]=s;return Se(r,t,n)}return e instanceof Set?Se(Array.from(e).sort((r,a)=>Se(r,t).localeCompare(Se(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?Se(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${Se(r,t)}:${Se(e[r],t,r)}`).join(",")}}`}function uu(e,t={allowFunctions:!1}){return Se(e,t)}var Ft=uu;const{TreeCache:du}=ir,vt={equality:"reference",eviction:"keep-all",maxSize:1/0};function fu({equality:e=vt.equality,eviction:t=vt.eviction,maxSize:n=vt.maxSize}=vt,o){const r=hu(e);return vu(t,n,r,o)}function hu(e){switch(e){case"reference":return t=>t;case"value":return t=>Ft(t)}throw U(`Unrecognized equality policy ${e}`)}function vu(e,t,n,o){switch(e){case"keep-all":return new du({name:o,mapNodeValue:n});case"lru":return qn({name:o,maxSize:H(t),mapNodeValue:n});case"most-recent":return qn({name:o,maxSize:1,mapNodeValue:n})}throw U(`Unrecognized eviction policy ${e}`)}var pu=fu;function _u(e){return()=>null}var Su={startPerfBlock:_u};const{isLoadable:mu,loadableWithError:pt,loadableWithPromise:Ru,loadableWithValue:Jt}=st,{WrappedValue:lr}=sr,{getNodeLoadable:_t,peekNodeLoadable:yu,setNodeValue:gu}=we,{saveDepsToStore:bu}=ct,{DEFAULT_VALUE:Tu,getConfigDeletionHandler:wu,getNode:Eu,registerNode:Zn}=ce,{isRecoilValue:Au}=xe,{markRecoilValueModified:Yn}=me,{retainedByOptionWithDefault:Nu}=Me,{recoilCallback:Lu}=ar,{startPerfBlock:Cu}=Su;class ur{}const Je=new ur,Qe=[],St=new Map,Vu=(()=>{let e=0;return()=>e++})();function dr(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=pu(r??{equality:"reference",eviction:"keep-all"},n),u=Nu(e.retainedBy_UNSTABLE),f=new Map;let v=0;function _(){return!z("recoil_memory_managament_2020")||v>0}function V(d){return d.getState().knownSelectors.add(n),v++,()=>{v--}}function C(){return wu(n)!==void 0&&!_()}function y(d,p,S,$,b){fe(p,$,b),E(d,S)}function E(d,p){le(d,p)&&Q(d),oe(p,!0)}function Z(d,p){le(d,p)&&(H(te(d)).stateVersions.clear(),oe(p,!1))}function oe(d,p){const S=St.get(d);if(S!=null){for(const $ of S)Yn($,H(t));p&&St.delete(d)}}function w(d,p){let S=St.get(p);S==null&&St.set(p,S=new Set),S.add(d)}function B(d,p,S,$,b,D){return p.then(k=>{if(!_())throw Q(d),Je;const T=Jt(k);return y(d,S,b,T,$),k}).catch(k=>{if(!_())throw Q(d),Je;if(W(k))return J(d,k,S,$,b,D);const T=pt(k);throw y(d,S,b,T,$),k})}function J(d,p,S,$,b,D){return p.then(k=>{if(!_())throw Q(d),Je;D.loadingDepKey!=null&&D.loadingDepPromise===p?S.atomValues.set(D.loadingDepKey,Jt(k)):d.getState().knownSelectors.forEach(x=>{S.atomValues.delete(x)});const T=Y(d,S);if(T&&T.state!=="loading"){if((le(d,b)||te(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!le(d,b)){const x=ye(d,S);if(x!=null)return x.loadingLoadable.contents}const[K,ne]=G(d,S,b);if(K.state!=="loading"&&y(d,S,b,K,ne),K.state==="hasError")throw K.contents;return K.contents}).catch(k=>{if(k instanceof ur)throw Je;if(!_())throw Q(d),Je;const T=pt(k);throw y(d,S,b,T,$),k})}function F(d,p,S,$){var b,D,k,T;if(le(d,$)||p.version===((b=d.getState())===null||b===void 0||(D=b.currentTree)===null||D===void 0?void 0:D.version)||p.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var K,ne,x;bu(n,S,d,(K=(ne=d.getState())===null||ne===void 0||(x=ne.nextTree)===null||x===void 0?void 0:x.version)!==null&&K!==void 0?K:d.getState().currentTree.version)}for(const X of S)s.add(X)}function G(d,p,S){const $=Cu(n);let b=!0,D=!0;const k=()=>{$(),D=!1};let T,K=!1,ne;const x={loadingDepKey:null,loadingDepPromise:null},X=new Map;function pe({key:he}){const ue=_t(d,p,he);switch(X.set(he,ue),b||(F(d,p,new Set(X.keys()),S),Z(d,S)),ue.state){case"hasValue":return ue.contents;case"hasError":throw ue.contents;case"loading":throw x.loadingDepKey=he,x.loadingDepPromise=ue.contents,ue.contents}throw U("Invalid Loadable state")}const Ne=he=>(...ue)=>{if(D)throw U("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&tt(!1),Lu(d,he,ue,{node:t})};try{T=o({get:pe,getCallback:Ne}),T=Au(T)?pe(T):T,mu(T)&&(T.state==="hasError"&&(K=!0),T=T.contents),W(T)?T=B(d,T,p,X,S,x).finally(k):k(),T=T instanceof lr?T.value:T}catch(he){T=he,W(T)?T=J(d,T,p,X,S,x).finally(k):(K=!0,k())}return K?ne=pt(T):W(T)?ne=Ru(T):ne=Jt(T),b=!1,Ue(d,S,X),F(d,p,new Set(X.keys()),S),[ne,X]}function Y(d,p){let S=p.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(D=>(typeof D!="string"&&tt(!1),_t(d,p,D).contents),{onNodeVisit:D=>{D.type==="branch"&&D.nodeKey!==n&&$.add(D.nodeKey)}})}catch(D){throw U(`Problem with cache lookup for selector "${n}": ${D.message}`)}if(S){var b;p.atomValues.set(n,S),F(d,p,$,(b=te(d))===null||b===void 0?void 0:b.executionID)}return S}function ae(d,p){const S=Y(d,p);if(S!=null)return Q(d),S;const $=ye(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(d,$.executionID),$.loadingLoadable}const D=Vu(),[k,T]=G(d,p,D);return k.state==="loading"?(de(d,D,k,T,p),w(d,D)):(Q(d),fe(p,k,T)),k}function ye(d,p){const S=Uo([f.has(d)?[H(f.get(d))]:[],Lt(_n(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[D,k]of b)if(!_t(d,p,D).is(k))return!0;return!1}for(const b of S){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function te(d){return f.get(d)}function de(d,p,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function Ue(d,p,S){if(le(d,p)){const $=te(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function Q(d){f.delete(d)}function le(d,p){var S;return p===((S=te(d))===null||S===void 0?void 0:S.executionID)}function Ae(d){return Array.from(d.entries()).map(([p,S])=>[p,S.contents])}function fe(d,p,S){d.atomValues.set(n,p);try{l.set(Ae(S),p)}catch($){throw U(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ge(d){if(Qe.includes(n)){const p=`Recoil selector has circular dependencies: ${Qe.slice(Qe.indexOf(n)).join("  ")}`;return pt(U(p))}Qe.push(n);try{return d()}finally{Qe.pop()}}function Ie(d,p){const S=p.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&tt(!1),(b=yu(d,p,$))===null||b===void 0?void 0:b.contents})}function ke(d,p){return ge(()=>ae(d,p))}function P(d){d.atomValues.delete(n)}function O(d,p){t==null&&tt(!1);for(const $ of s){var S;const b=Eu($);(S=b.clearCache)===null||S===void 0||S.call(b,d,p)}s.clear(),P(p),l.clear(),Yn(d,t)}return a!=null?t=Zn({key:n,nodeType:"selector",peek:Ie,get:ke,set:(p,S,$)=>{let b=!1;const D=new Map;function k({key:x}){if(b)throw U("Recoil: Async selector sets are not currently supported.");const X=_t(p,S,x);if(X.state==="hasValue")return X.contents;if(X.state==="loading"){const pe=`Getting value of asynchronous atom or selector "${x}" in a pending state while setting selector "${n}" is not yet supported.`;throw U(pe)}else throw X.contents}function T(x,X){if(b)throw U("Recoil: Async selector sets are not currently supported.");const pe=typeof X=="function"?X(k(x)):X;gu(p,S,x.key,pe).forEach((he,ue)=>D.set(ue,he))}function K(x){T(x,Tu)}const ne=a({set:T,get:k,reset:K},$);if(ne!==void 0)throw W(ne)?U("Recoil: Async selector sets are not currently supported."):U("Recoil: selector set should be a void function.");return b=!0,D},init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=Zn({key:n,nodeType:"selector",peek:Ie,get:ke,init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}dr.value=e=>new lr(e);var We=dr;const{isLoadable:$u,loadableWithError:Qt,loadableWithPromise:en,loadableWithValue:Be}=st,{WrappedValue:fr}=sr,{peekNodeInfo:Mu}=we,{DEFAULT_VALUE:Le,DefaultValue:Te,getConfigDeletionHandler:hr,registerNode:Uu,setConfigDeletionHandler:Iu}=ce,{isRecoilValue:ku}=xe,{getRecoilValueAsLoadable:Du,markRecoilValueModified:Bu,setRecoilValue:Xn,setRecoilValueLoadable:Pu}=me,{retainedByOptionWithDefault:Ou}=Me,et=e=>e instanceof fr?e.value:e;function xu(e){const{key:t,persistence_UNSTABLE:n}=e,o=Ou(e.retainedBy_UNSTABLE);let r=0;function a(w){return en(w.then(B=>(s=Be(B),B)).catch(B=>{throw s=Qt(B),B}))}let s=W(e.default)?a(e.default):$u(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Be(et(e.default));s.contents;let l;const u=new Map;function f(w){return w}function v(w,B){const J=B.then(F=>{var G,Y;return((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&Xn(w,oe,F),F}).catch(F=>{var G,Y;throw((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&Pu(w,oe,Qt(F)),F});return J}function _(w,B,J){var F;r++;const G=()=>{var te;r--,(te=u.get(w))===null||te===void 0||te.forEach(de=>de()),u.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const te=()=>{var de;((de=w.getState().nextTree)!==null&&de!==void 0?de:w.getState().currentTree).atomValues.has(t)||Bu(w,oe)};s.contents.finally(te)}const Y=(F=e.effects)!==null&&F!==void 0?F:e.effects_UNSTABLE;if(Y!=null){let te=function(P){if(le&&P.key===t){const O=Q;return O instanceof Te?V(w,B):W(O)?en(O.then(d=>d instanceof Te?s.toPromise():d)):Be(O)}return Du(w,P)},de=function(P){return te(P).toPromise()},Ue=function(P){var O;const d=Mu(w,(O=w.getState().nextTree)!==null&&O!==void 0?O:w.getState().currentTree,P.key);return le&&P.key===t&&!(Q instanceof Te)?{...d,isSet:!0,loadable:te(P)}:d},Q=Le,le=!0,Ae=!1,fe=null;const ge=P=>O=>{if(le){const d=te(oe),p=d.state==="hasValue"?d.contents:Le;Q=typeof O=="function"?O(p):O,W(Q)&&(Q=Q.then(S=>(fe={effect:P,value:S},S)))}else{if(W(O))throw U("Setting atoms to async values is not implemented.");typeof O!="function"&&(fe={effect:P,value:et(O)}),Xn(w,oe,typeof O=="function"?d=>{const p=et(O(d));return fe={effect:P,value:p},p}:et(O))}},Ie=P=>()=>ge(P)(Le),ke=P=>O=>{var d;const{release:p}=w.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:D}=S.getState();D||(D=b);const k=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(k.state==="hasValue"){var T,K,ne,x;const X=k.contents,pe=(T=D.atomValues.get(t))!==null&&T!==void 0?T:s,Ne=pe.state==="hasValue"?pe.contents:Le;((K=fe)===null||K===void 0?void 0:K.effect)!==P||((ne=fe)===null||ne===void 0?void 0:ne.value)!==X?O(X,Ne,!b.atomValues.has(t)):((x=fe)===null||x===void 0?void 0:x.effect)===P&&(fe=null)}},t);u.set(w,[...(d=u.get(w))!==null&&d!==void 0?d:[],p])};for(const P of Y)try{const O=P({node:oe,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:J,setSelf:ge(P),resetSelf:Ie(P),onSet:ke(P),getPromise:de,getLoadable:te,getInfo_UNSTABLE:Ue});if(O!=null){var ae;u.set(w,[...(ae=u.get(w))!==null&&ae!==void 0?ae:[],O])}}catch(O){Q=O,Ae=!0}if(le=!1,!(Q instanceof Te)){var ye;const P=Ae?Qt(Q):W(Q)?en(v(w,Q)):Be(et(Q));P.contents,B.atomValues.set(t,P),(ye=w.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return G}function V(w,B){var J,F;return(J=(F=B.atomValues.get(t))!==null&&F!==void 0?F:l)!==null&&J!==void 0?J:s}function C(w,B){if(B.atomValues.has(t))return H(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const J=B.nonvalidatedAtoms.get(t),F=n.validator(J,Le);return l=F instanceof Te?s:Be(F),l}else return s}function y(){l=void 0}function E(w,B,J){if(B.atomValues.has(t)){const F=H(B.atomValues.get(t));if(F.state==="hasValue"&&J===F.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof Te)return new Map;return l=void 0,new Map().set(t,Be(J))}function Z(){return hr(t)!==void 0&&r<=0}const oe=Uu({key:t,nodeType:"atom",peek:V,get:C,set:E,init:_,invalidate:y,shouldDeleteConfigOnRelease:Z,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return oe}function An(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return ku(n)?Fu({...t,default:n}):xu({...t,default:n})}function Fu(e){const t=An({...e,default:Le,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Te?o:H(e.persistence_UNSTABLE).validator(o,Le)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=We({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Te?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Iu(n.key,hr(e.key)),n}An.value=e=>new fr(e);var vr=An;class zu{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Wu={MapCache:zu},Gu=Wu.MapCache,Ku=Object.freeze({__proto__:null,MapCache:Gu});const{LRUCache:Jn}=cr,{MapCache:ju}=Ku,mt={equality:"reference",eviction:"none",maxSize:1/0};function Hu({equality:e=mt.equality,eviction:t=mt.eviction,maxSize:n=mt.maxSize}=mt){const o=qu(e);return Zu(t,n,o)}function qu(e){switch(e){case"reference":return t=>t;case"value":return t=>Ft(t)}throw U(`Unrecognized equality policy ${e}`)}function Zu(e,t,n){switch(e){case"keep-all":return new ju({mapKey:n});case"lru":return new Jn({mapKey:n,maxSize:H(t)});case"most-recent":return new Jn({mapKey:n,maxSize:1})}throw U(`Unrecognized eviction policy ${e}`)}var pr=Hu;const{setConfigDeletionHandler:Yu}=ce;function Xu(e){var t,n;const o=pr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,v="default"in e?e.default:new Promise(()=>{}),_=vr({...f,key:`${e.key}__${(a=Ft(r))!==null&&a!==void 0?a:"void"}`,default:typeof v=="function"?v(r):v,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,_),Yu(_.key,()=>{o.delete(r)}),_}}var Ju=Xu;const{setConfigDeletionHandler:Qu}=ce;let ed=0;function td(e){var t,n;const o=pr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(V){throw U(`Problem with cache lookup for selector ${e.key}: ${V.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Ft(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${ed++}`,u=V=>e.get(r)(V),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let _;if(e.set!=null){const V=e.set;_=We({key:l,get:u,set:(y,E)=>V(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else _=We({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,_),Qu(_.key,()=>{o.delete(r)}),_}}var Ee=td;const nd=Ee({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function od(e){return nd(e)}var rd=od;const ad=Ee({key:"__error",get:e=>()=>{throw U(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function sd(e){return ad(e)}var id=sd;function cd(e){return e}var ld=cd;const{loadableWithError:_r,loadableWithPromise:Sr,loadableWithValue:mr}=st;function zt(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function ud(e){return e!=null&&!W(e)}function Wt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function un(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?mr(t[a]):W(r)?Sr(r):_r(r));return un(e,o)}function dd(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const fd=Ee({key:"__waitForNone",get:e=>({get:t})=>{const n=Wt(e),[o,r]=zt(t,n);return Pe(e,o,r)},dangerouslyAllowMutability:!0}),hd=Ee({key:"__waitForAny",get:e=>({get:t})=>{const n=Wt(e),[o,r]=zt(t,n);return r.some(a=>!W(a))?Pe(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())W(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Pe(e,o,r))}).catch(u=>{r[s]=u,a(Pe(e,o,r))})})},dangerouslyAllowMutability:!0}),vd=Ee({key:"__waitForAll",get:e=>({get:t})=>{const n=Wt(e),[o,r]=zt(t,n);if(r.every(s=>s==null))return un(e,o);const a=r.find(ud);if(a!=null)throw a;return Promise.all(r).then(s=>un(e,dd(o,s)))},dangerouslyAllowMutability:!0}),pd=Ee({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Wt(e),[o,r]=zt(t,n);return r.every(a=>!W(a))?Pe(e,o,r):Promise.all(r.map((a,s)=>W(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Pe(e,o,r))},dangerouslyAllowMutability:!0}),_d=Ee({key:"__noWait",get:e=>({get:t})=>{try{return We.value(mr(t(e)))}catch(n){return We.value(W(n)?Sr(n):_r(n))}},dangerouslyAllowMutability:!0});var Sd={waitForNone:fd,waitForAny:hd,waitForAll:vd,waitForAllSettled:pd,noWait:_d};const{RecoilLoadable:md}=st,{DefaultValue:Rd}=ce,{RecoilRoot:yd,useRecoilStoreID:gd}=be,{isRecoilValue:bd}=xe,{retentionZone:Td}=Vt,{freshSnapshot:wd}=Dt,{useRecoilState:Ed,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Ad,useRecoilStateLoadable:Nd,useRecoilValue:Ld,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Cd,useRecoilValueLoadable:Vd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:$d,useResetRecoilState:Md,useSetRecoilState:Ud}=Wc,{useGotoRecoilSnapshot:Id,useRecoilSnapshot:kd,useRecoilTransactionObserver:Dd}=tr,{useRecoilCallback:Bd}=ar,{noWait:Pd,waitForAll:Od,waitForAllSettled:xd,waitForAny:Fd,waitForNone:zd}=Sd;var ft={DefaultValue:Rd,isRecoilValue:bd,RecoilLoadable:md,RecoilEnv:Ge,RecoilRoot:yd,useRecoilStoreID:gd,useRecoilBridgeAcrossReactRoots_UNSTABLE:_l,atom:vr,selector:We,atomFamily:Ju,selectorFamily:Ee,constSelector:rd,errorSelector:id,readOnlySelector:ld,noWait:Pd,waitForNone:zd,waitForAny:Fd,waitForAll:Od,waitForAllSettled:xd,useRecoilValue:Ld,useRecoilValueLoadable:Vd,useRecoilState:Ed,useRecoilStateLoadable:Nd,useSetRecoilState:Ud,useResetRecoilState:Md,useGetRecoilValueInfo_UNSTABLE:ul,useRecoilRefresher_UNSTABLE:Kl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:$d,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Cd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Ad,useRecoilCallback:Bd,useRecoilTransaction_UNSTABLE:Yl,useGotoRecoilSnapshot:Id,useRecoilSnapshot:kd,useRecoilTransactionObserver_UNSTABLE:Dd,snapshot_UNSTABLE:wd,useRetain:gn,retentionZone:Td},Wd=ft.RecoilRoot,je=ft.atom,Rr=ft.selector,yr=ft.useRecoilValue,He=ft.useRecoilState;const gr=je({key:"tableColumnFilters",default:[]}),br=()=>He(gr),Gd=je({key:"chartTab",default:"desktop"}),Tr=()=>He(Gd),wr=je({key:"counter",default:0}),Kd=()=>He(wr),Er=je({key:"githubSearch",default:""}),jd=()=>He(Er),Ar=je({key:"sliderValue",default:0}),Hd=()=>He(Ar),Nr=je({key:"timer",default:0}),qd=()=>He(Nr),Zd=Rr({key:"allValues",get:({get:e})=>({tableColumnFilters:e(gr),counter:e(wr),sliderValue:e(Ar),timer:e(Nr)})}),Yd=()=>yr(Zd),Xd=Rr({key:"githubUser",get:({get:e})=>Fr(e(Er))}),Jd=()=>yr(Xd),Qd=e=>{const[t,n]=qd();return ee.jsx(zr,{className:e.className,timer:t,setTimer:n})},ef=e=>{const[t,n]=Kd();return ee.jsx(Wr,{className:e.className,counter:t,setCounter:n,children:ee.jsx(Qd,{})})},tf=e=>{const[t,n]=Hd();return ee.jsx(Gr,{className:e.className,value:t,setValue:n,children:ee.jsx(ef,{})})},nf=()=>{const[e,t]=Tr();return ee.jsx(Kr,{chartTab:e,setChartTab:t})},of=e=>{const[t,n]=jd();return ee.jsx(jr,{className:e.className,value:t,setValue:n,children:ee.jsx(nf,{})})},rf=e=>{var o;const[t,n]=br();return ee.jsxs(Hr,{className:e.className,value:(o=t[0])==null?void 0:o.value,onChange:r=>n([{id:"email",value:r}]),children:[ee.jsx(tf,{}),ee.jsx(of,{})]})},af=e=>{const[t,n]=br();return ee.jsx(qr,{className:e.className,tableColumnFilters:t,setTableColumnFilters:n})},sf=e=>{const[t,n]=Tr();return ee.jsx(Zr,{className:e.className,chartTab:t,setChartTab:n,children:ee.jsx(af,{})})},cf=e=>{var a;const{tableColumnFilters:t,sliderValue:n,counter:o,timer:r}=Yd();return ee.jsx(Yr,{className:e.className,sliderValue:n,searchText:(a=t[0])==null?void 0:a.value,counter:o,timer:r})},lf=e=>{const t=Jd();return ee.jsx(Xr,{className:e.className,user:t})},ff=()=>ee.jsx(Wd,{children:ee.jsxs(Jr,{className:Or("m-4 grid grid-cols-10 gap-2 p-2 shadow-sm",xr[0]),children:[ee.jsx(rf,{className:"col-span-3"}),ee.jsx(sf,{className:"col-span-7"}),ee.jsx(cf,{className:"col-span-5"}),ee.jsx(lf,{className:"col-span-5"})]})});export{ff as RecoilPage};
